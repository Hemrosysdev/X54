/*
 * FreeRtosTimerInterface.cpp
 *
 *  Created on: 27.10.2019
 *      Author: gesser
 */

/*!************************************************************************************************************************************************************
 *
 *************************************************************************************************************************************************************/

#include "FreeRtosTimerInterface.h"
#include "YakinduFreeRtosTimer.h"
#include "SystemStateCtrlQueue.h"

/*!************************************************************************************************************************************************************
 *
 *************************************************************************************************************************************************************/

FreeRtosTimerInterface::FreeRtosTimerInterface( SystemStateCtrlQueue * pQueue )
    : UxEspCppLibrary::EspLog( "FreeRtosTimerInterface" )
    , m_pQueue( pQueue )
{
}

/*!************************************************************************************************************************************************************
 *
 *************************************************************************************************************************************************************/

FreeRtosTimerInterface::~FreeRtosTimerInterface()
{
    std::map<sc_eventid, YakinduFreeRtosTimer *>::iterator i;

    for ( i = m_theTimerMap.begin(); i != m_theTimerMap.end(); i++ )
    {
        delete i->second;
    }
    m_theTimerMap.clear();

    m_pQueue = nullptr;
}

/*!************************************************************************************************************************************************************
 *
 *************************************************************************************************************************************************************/

void FreeRtosTimerInterface::setTimer( sc::timer::TimedInterface * statemachine,
                                       sc_eventid                  event,
                                       sc_integer                  time_ms,
                                       sc_boolean                  isPeriodic )
{
    //vlogInfo( "setTimer: ev=%x ms=%d cy=%d", event, time_ms, isPeriodic );

    YakinduFreeRtosTimer * pTimer = m_theTimerMap[event];

    if ( !pTimer )
    {
        //vlogWarning( "Create new timer %x", event );
        pTimer               = new YakinduFreeRtosTimer( m_pQueue, event );
        m_theTimerMap[event] = pTimer;
    }

    if ( isPeriodic )
    {
        pTimer->startPeriodic( time_ms * 1000 );
    }
    else
    {
        pTimer->startOnce( time_ms * 1000 );
    }
}

/*!************************************************************************************************************************************************************
 *
 *************************************************************************************************************************************************************/

void FreeRtosTimerInterface::unsetTimer( sc::timer::TimedInterface * statemachine,
                                         sc_eventid                  event )
{
    //vlogInfo( "unsetTimer: ev=%x", event );

    YakinduFreeRtosTimer * pTimer = m_theTimerMap[event];

    if ( pTimer )
    {
        pTimer->stop();
    }
}

/*!************************************************************************************************************************************************************
 *
 *************************************************************************************************************************************************************/

void FreeRtosTimerInterface::cancel()
{
    vlogInfo( "cancel FreeRtosTimerInterface" );
}

/*!************************************************************************************************************************************************************
 *
 *************************************************************************************************************************************************************/

